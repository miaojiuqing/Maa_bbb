# 战斗逻辑编写指南（基于当前项目框架）

本指南描述如何在本仓库中**新增/编写一份“战斗逻辑（角色战斗脚本）”**，并解释它与：

- `agent/custom/utils/BattleCore.py`（战斗逻辑框架/通用动作封装）
- `agent/custom/action/Role/`（角色战斗逻辑实现）
- `agent/custom/utils/RoleConfiguration.py`（角色识别与逻辑映射配置）
- `assets/resource/pipeline/战斗逻辑/*`（战斗动作与识别节点）

之间的关系。

---

## 总览：战斗逻辑是如何跑起来的

### 核心链路（强烈建议先理解这个）

1. **Pipeline 入口**：`assets/resource/pipeline/战斗逻辑/战斗接口.json` 定义了 `自动战斗` 节点：
   - 先执行 `识别人物`（一个 Custom Action：`IDFRole`）
   - 再跳转到 `战斗程序`（一个“动态注入”的节点）
2. **战斗中识别当前角色**：`agent/custom/action/IDFRole.py` 会：
   - 读取 `agent/custom/utils/RoleConfiguration.py` 的 `ROLE_CONFIG`
   - 用每个角色的 `attack_template` 逐个做模板匹配（节点名 `在战斗中检查角色`，定义在 `assets/resource/pipeline/战斗逻辑/自动战斗工具方法.jsonc`）
   - 匹配成功后，通过 `context.override_pipeline(...)` 把 pipeline 的 `战斗程序` 改成：
     - `action: Custom`
     - `custom_action: role_info["cls_name"]`（即你角色逻辑的“注册名”）
3. **运行角色战斗逻辑**：`战斗程序` 执行对应的 Custom Action（也就是 `agent/custom/action/Role/*.py` 中的类）。
4. **换人/切回识别**：在角色逻辑里通常会调用 `CombatActions.switch()`，它会在切人完成后重新启用 pipeline 的 `识别人物` 节点，让下一轮继续识别当前上场角色并切换脚本。

你新增一个角色战斗逻辑，需要同时把这 3 件事对齐：

- **Python 实现**：写一个 `CustomAction` 类（角色逻辑）
- **Agent 注册**：在 `agent/CustomFile.py` 用 `@AgentServer.custom_action("xxx")` 注册它
- **角色配置**：在 `RoleConfiguration.ROLE_CONFIG` 里把 `cls_name` 配成这个注册名，并配置 `attack_template`

---

## 目录结构与职责分工

### Python：战斗逻辑与框架

- `agent/custom/utils/BattleCore.py`
  - `CombatActions`：对 `context.run_action(...)` / `context.run_recognition(...)` 的一层封装
  - 提供常用能力：攻击/闪避/技能/必杀/QTE/锁定镜头/协同者、血量 OCR、必杀能量 OCR、切人逻辑等
- `agent/custom/action/Role/*.py`
  - 每个角色一个类，继承 `maa.custom_action.CustomAction`
  - 入口方法固定为 `run(self, context, argv) -> RunResult`
- `agent/CustomFile.py`
  - 统一注册 custom actions（决定 pipeline 里 `custom_action` 名字能不能被框架找到）

### 资源：动作节点与识别节点（Pipeline）

通用战斗动作（节点名固定，供 Python 调用）：

- `assets/resource/pipeline/战斗逻辑/自动战斗按键.jsonc`
  - 定义：`攻击_action`、`长按攻击_action`、`闪避_action`、`技能_action`、`必杀_action`、`qte1/qte2` 等
- Win32 资源一般会覆盖为按键输入版本：
  - `assets/resource_win32/pipeline/战斗逻辑/自动战斗按键.jsonc`
  - **节点名不变**，只是底层动作类型从 Click/LongPress 变成 ClickKey/KeyDown 等

通用识别节点（供 Python `check_status` / OCR 使用）：

- `assets/resource/pipeline/战斗逻辑/自动战斗工具方法.jsonc`
  - `战斗中`、`技能_能量条`、`技能_必杀能量`、`检查血量百分比`、`在战斗中检查角色`、`本关卡无法复活` 等

角色专属状态识别（你自己新增/维护）：

- 推荐放在 `assets/resource/pipeline/战斗逻辑/战斗逻辑/<角色>.jsonc`
  - 示例：`assets/resource/pipeline/战斗逻辑/战斗逻辑/真理之律者.jsonc`
  - 常见用途：判定“是否在某阶段/是否能长按/是否该放大招/是否某 UI 亮起”等

---

## 第 1 部分：写一个角色战斗逻辑（Python）

### 1) 基本模板（最小可运行）

在 `agent/custom/action/Role/` 下新增文件，比如 `MyRole.py`：

```python
import time
from maa.context import Context
from maa.custom_action import CustomAction

from ...utils.BattleCore import CombatActions


class MyRole(CustomAction):
    def run(self, context: Context, argv: CustomAction.RunArg) -> CustomAction.RunResult:
        ATC = CombatActions(context=context, role_name="我的角色名(用于日志)")

        # 简单循环：技能 -> 普攻若干次 -> 视情况放必杀
        ATC.use_skill()
        time.sleep(0.05)

        for _ in range(10):
            if context.tasker.stopping:  # 推荐：任何循环都加中断
                return CustomAction.RunResult(success=True)
            ATC.attack()
            time.sleep(0.05)

        if ATC.check_ultimate_energy_bar():
            ATC.use_ultimate_skill()

        # 通常：打完一轮主动切人，交给下一轮识别
        ATC.switch()

        return CustomAction.RunResult(success=True)
```

### 2) 推荐写法：用“状态识别 + 动作序列”拼装

本项目里最常用的拼装方式是：

- 用 `ATC.check_status("某个识别节点名")` 判断阶段/状态
- 根据状态分支执行动作序列（`attack()` / `use_skill()` / `long_press_attack()` / `dodge()`…）

典型例子：`agent/custom/action/Role/HerrscherOfTruth.py` 里用：

- `检查常规状态_真理之律者`（TemplateMatch）
- `检查必杀阶段动能条满_真理之律者`（ColorMatch）

来决定分支和长按时机。

### 3) 循环里必须注意的 3 件事（很容易踩坑）

- **停止条件**：任何长循环都要检查 `context.tasker.stopping`，否则 UI 停止任务时脚本还会继续按键/点屏。
- **节奏控制**：动作之间加 `time.sleep(...)`（毫秒级也行），避免触发过快导致识别失败/吞按键。
- **先判断“战斗中”再按键**：`CombatActions.attack()/dodge()/use_skill()/use_ultimate_skill()` 内部会先识别 `战斗中`，不在战斗时会直接返回 False，减少误触。

---

## 第 2 部分：使用 `CombatActions` 的通用能力（BattleCore）

### 常用动作（对应 pipeline 的 action 节点）

- `attack()`：`攻击_action`
- `long_press_attack(duration=1000)`：`长按攻击_action`（会用 `context.override_pipeline` 临时覆盖 `duration`）
- `dodge()`：`闪避_action`
- `long_press_dodge(duration=1000)`：`长按闪避_action`
- `use_skill(duration=0)`：`技能_action` 后等待 `duration` 毫秒
- `use_ultimate_skill(duration=0)`：`必杀_action` 后等待 `duration` 毫秒
- `trigger_qte(target=1|2)`：`qte1` / `qte2`
- `lens_lock()`：`锁定视角_action`
- `co_operation()`：`协同者_action`

### 常用识别/数值读取

- `check_status(node, pipeline_override={})`
  - 从当前截图运行 `context.run_recognition(node, image, pipeline_override)`
  - 命中返回识别结果，否则返回 False
  - **用途**：用资源侧 node 做“阶段判定”
- `check_ultimate_energy_bar() -> bool`
  - OCR `技能_能量条`（形如 `x/y`）与 `技能_必杀能量`（需要值）
  - 当前能量 >= 需要值，返回 True
- `get_hp_percent(return_percent=True) -> int`
  - OCR `检查血量百分比`（形如 `x/y`）
  - 默认返回 0~100

### 换人（很关键）

- `switch()`
  - 读取 pipeline 节点 `准备切换角色` 的 `post_delay` 当作目标位（1/2）
  - 调用 `trigger_qte(target)` 尝试切人
  - 通过“最大血量变化”判断是否切人成功
  - 若遇到 `本关卡无法复活` 弹窗，会点确认并尝试切到另一个人
  - 切换完成后会 `context.override_pipeline({"识别人物": {"enabled": True}})` 让下一轮重新识别当前角色并注入脚本

---

## 第 3 部分：把你的角色逻辑接进系统（配置与注册）

### 1) 在 `RoleConfiguration.py` 增加配置

编辑 `agent/custom/utils/RoleConfiguration.py`，增加一个条目：

```python
ROLE_CONFIG["我的角色名"] = {
    "cls_name": "MyRole",  # 必须与 CustomFile.py 里的注册名一致
    "metadata": {
        "DMG": "fire",      # fire|ice|lightning|physical
        "type": "mecha",    # mecha|psy|bio|qua|img|sd
        "weight": 2,
    },
    "template": [
        "自动战斗识别/我的角色头像.png",
    ],
    "attack_template": "自动战斗索引/我的角色攻击键模板.png",
}
```

字段说明：

- `cls_name`：战斗内识别成功后，要切换执行的 custom action 名字
- `template`：头像模板（目前这份配置主要用于扩展/未来选人逻辑；战斗内识别用的是 `attack_template`）
- `attack_template`：**战斗中识别当前角色**的模板图（`IDFRole.py` 会用它做 `TemplateMatch`）

### 2) 在 `CustomFile.py` 注册 custom action

编辑 `agent/CustomFile.py`，导入你的类并注册：

```python
from agent.custom.action.Role.MyRole import MyRole


@AgentServer.custom_action("MyRole")
class MyRole_Cls(MyRole):
    def __init__(self):
        super().__init__()
        print(f"{self.__class__.__name__} 初始化")
```

注意点：

- `@AgentServer.custom_action("MyRole")` 里的字符串就是 pipeline 里的 `custom_action` 名字
- 必须与 `RoleConfiguration.py` 中的 `cls_name` 完全一致（区分大小写）

### 3) 准备识别模板图片

你至少需要提供：

- `assets/resource/image/自动战斗索引/<你的角色>.png`（战斗中识别用）

并确保在 `RoleConfiguration.py` 的 `attack_template` 指向它。

> 提示：ROI 默认由 `assets/resource/pipeline/战斗逻辑/自动战斗工具方法.jsonc` 的 `在战斗中检查角色` 决定（当前是右下角攻击键附近区域）。如果你的模板不容易命中，通常是 ROI/阈值/绿幕掩膜需要调整。

---

## 第 4 部分：新增/调整“角色专属状态节点”（可选但很常用）

如果你的角色需要判断“某阶段 UI 是否出现/某条是否满/某键是否亮”，建议新增专属识别节点，然后在 Python 用 `ATC.check_status(...)` 调用。

### 推荐文件位置

在 `assets/resource/pipeline/战斗逻辑/战斗逻辑/` 下新增 `<角色>.jsonc`。

### 示例：TemplateMatch（阶段/形态判定）

参考 `真理之律者.jsonc` 的写法：

```jsonc
{
  "检查常规状态_我的角色": {
    "recognition": {
      "type": "TemplateMatch",
      "param": {
        "roi": [1061, 494, 219, 226],
        "template": ["自动战斗索引/我的角色.png"]
      }
    }
  }
}
```

### 示例：ColorMatch（能量条/按钮高亮判定）

```jsonc
{
  "检查某条是否满_我的角色": {
    "recognition": {
      "type": "ColorMatch",
      "param": {
        "roi": [650, 620, 20, 20],
        "lower": [200, 120, 40],
        "upper": [255, 160, 90],
        "count": 20,
        "connected": true
      }
    }
  }
}
```

### Python 侧调用

```python
if ATC.check_status("检查某条是否满_我的角色"):
    ATC.long_press_attack(700)
```

### 小技巧：不改资源文件，先在 Python 里临时覆盖参数

`check_status` 支持 `pipeline_override`，可以快速试 ROI/threshold/template：

```python
hit = ATC.check_status(
    "在战斗中检查角色",
    pipeline_override={
        "在战斗中检查角色": {
            "recognition": {
                "param": {"template": "自动战斗索引/我的角色.png", "threshold": 0.85}
            }
        }
    },
)
```

---

## 第 5 部分：两种常见的“写法路线”

### 路线 A：纯 Python 编排（适合精细操作/小循环）

像 `HerrscherOfTruth.py` / `GeneralFight.py` 一样：

- 全部用 `CombatActions` + `check_status` + `sleep` 拼动作
- 优点：逻辑集中，调试直观
- 缺点：动作和识别的参数更多写在代码里，可复用性略低

### 路线 B：Pipeline 写循环，Python 只负责触发（适合长循环/大量 MultiSwipe）

像 `LoveElf.py` / `SpinaAstera.py` 一样：

- 在 `assets/resource/pipeline/战斗逻辑/乐土战斗/*.json` 里把循环写成一堆节点
- Python 里直接 `context.run_action("自动战斗-乐土-xxx战斗循环")`
- 优点：大量坐标/滑动/多分支更适合留在资源里调整
- 缺点：需要熟悉 pipeline 的 next/recognition/action 组织方式

---

## 调试建议（强烈推荐）

- **日志**：
  - `CombatActions` 会写入 `debug/custom_YYYYMMDD.log`（带 role_name）
  - `Logger` 会写入 `debug/agent.log`（适合做 UI 输出/计数等）

- **节点调试**：
  - 推荐使用 `MaaDebugger` / `Maa Pipeline Support` 插件，快速取 ROI、取色、验证识别阈值

---

## 常见问题（FAQ）

### Q1：写了角色类，但战斗中从来不执行

排查顺序：

1. `RoleConfiguration.py` 的 `cls_name` 是否与 `CustomFile.py` 里 `@custom_action("...")` 完全一致
2. `attack_template` 是否存在、路径是否正确（相对 `assets/resource/image/`）
3. `assets/resource/pipeline/战斗逻辑/自动战斗工具方法.jsonc` 的 `在战斗中检查角色` ROI 是否覆盖到你模板所在区域
4. 模板阈值是否太高（`IDFRole.py` 目前用 `threshold: 0.8`）

### Q2：切人后脚本没有跟着换

确保你的角色逻辑最后调用了 `ATC.switch()`（或在合适时机调用），因为它会把 pipeline 的 `识别人物` 节点重新启用，下一轮才会识别新角色并注入对应脚本。

### Q3：动作按键错位/识别一直 miss

基本都是“分辨率/资源包/ROI”问题：

- 确认游戏分辨率是 16:9
- Win32/模拟器使用了正确的资源包（`resource_win32` vs `resource`）
- 用调试工具重新取 ROI/重截模板图
