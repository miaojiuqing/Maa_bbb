# 战斗逻辑编写指南

本指南面向**刚接触本项目的开发者**，手把手教你如何**新增一套角色的战斗脚本**。

在开始之前，你只需要知道以下 4 个核心文件/文件夹的作用即可：

| 文件/文件夹 | 作用 |
| --- | --- |
| `agent/custom/utils/BattleCore.py` | 封装好的"战斗工具箱"，提供攻击、闪避、放技能等现成方法 |
| `agent/custom/action/Role/` | 存放每个角色战斗脚本的文件夹，一个角色一个文件 |
| `agent/custom/utils/RoleConfiguration.py` | 角色配置表，告诉程序"哪个角色对应哪个脚本" |
| `agent/CustomFile.py` | 注册表，把你写好的角色脚本"登记"到框架中 |

---

## 先搞懂：战斗脚本是怎么运行起来的

### 核心流程（强烈建议先看懂这一段）

整个自动战斗的运行过程分 4 步：

```
截图识别当前角色 → 切换到对应的角色脚本 → 执行战斗动作 → 切人后重新识别
```

详细展开：

1. **识别当前角色**：程序会截取一张游戏画面，然后拿每个角色的"攻击键图片"去逐个比对。比对成功就知道当前是谁在场上。
2. **切换到对应脚本**：识别成功后，程序会自动把战斗流程切换到你写的那个角色脚本上。
3. **执行角色战斗逻辑**：你写的脚本开始运行——放技能、普攻、闪避、放大招……
4. **切人并重新识别**：脚本执行完毕后调用切人方法，切人后程序会回到第 1 步，识别新上场的角色，再执行对应脚本。

### 新增一个角色，你需要做 3 件事

- **写脚本**：在 `agent/custom/action/Role/` 下新建一个角色文件
- **登记注册**：在 `agent/CustomFile.py` 里把你的脚本注册进框架
- **配置角色信息**：在 `agent/custom/utils/RoleConfiguration.py` 里填写角色名称、识别图片等信息

下面会一步步教你怎么做。

---

## 文件结构一览

### 代码部分

- `agent/custom/utils/BattleCore.py`
  - 战斗工具箱，封装了各种常用战斗操作（攻击、闪避、放技能、读血量等）
  - 你写角色脚本时，直接调用这些现成方法就行
- `agent/custom/action/Role/*.py`
  - 每个角色一个文件，里面写具体的战斗逻辑（按什么顺序放技能、什么时候闪避等）
- `agent/CustomFile.py`
  - 注册表，把所有自定义的角色脚本统一登记，让框架能找到它们

### 资源部分（游戏内动作和识别）

通用战斗按键（所有角色共用，一般不需要改）：

- `assets/resource/pipeline/战斗逻辑/自动战斗按键.jsonc`
  - 定义了：`攻击_action`、`长按攻击_action`、`闪避_action`、`技能_action`、`必杀_action`、`qte1`/`qte2` 等
- 电脑端会用按键版覆盖：
  - `assets/resource_win32/pipeline/战斗逻辑/自动战斗按键.jsonc`
  - 节点名不变，只是底层从"点击屏幕"变成"按键盘"

通用识别节点（判断"是否在战斗中"、读取血量/能量等）：

- `assets/resource/pipeline/战斗逻辑/自动战斗工具方法.jsonc`
  - 包含：`战斗中`、`技能_能量条`、`技能_必杀能量`、`检查血量百分比`、`在战斗中检查角色`、`本关卡无法复活` 等

角色专属识别（可选，按需新增）：

- 建议放在 `assets/resource/pipeline/战斗逻辑/战斗逻辑/<角色名>.jsonc`
  - 例如：`真理之律者.jsonc`
  - 用途：判断"角色是否处于某个特殊阶段"、"某个能量条是否满了"等

---

## 第 1 步：写一个角色战斗脚本

### 1) 最简模板（复制就能跑）

在 `agent/custom/action/Role/` 下新建一个文件，比如叫 `MyRole.py`：

```python
import time
from maa.context import Context
from maa.custom_action import CustomAction

from ...utils.BattleCore import CombatActions


class MyRole(CustomAction):
    """我的角色 战斗逻辑"""

    def run(self, context: Context, argv: CustomAction.RunArg) -> CustomAction.RunResult:
        # 创建战斗工具箱，role_name 用于日志显示，写角色名方便排查问题
        工具箱 = CombatActions(context=context, role_name="我的角色")

        # ===== 战斗流程开始 =====
        # 先放一个技能
        工具箱.use_skill()
        time.sleep(0.05)  # 稍等一下，防止操作太快

        # 连续普攻 10 次
        for _ in range(10):
            if context.tasker.stopping:  # 检查用户是否点了"停止"按钮
                return CustomAction.RunResult(success=True)
            工具箱.attack()
            time.sleep(0.05)

        # 如果大招能量够了就放大招
        if 工具箱.check_ultimate_energy_bar():
            工具箱.use_ultimate_skill()

        # 切换到下一个角色（这步很重要！不写的话不会自动换人）
        工具箱.switch()

        return CustomAction.RunResult(success=True)
```

> **关于变量名**：上面用了中文变量名 `工具箱` 是为了方便理解。实际项目中现有代码习惯用 `ATC` 作为变量名，虽然两种都能正常运行，但实际使用还是要用`ATC`作为变量名。

### 2) 进阶写法：根据角色状态选择不同打法

大部分角色脚本的写法是这样的：

- 先**识别角色当前处于什么状态**（比如普通状态、大招状态、某个技能可释放等）
- 再根据不同状态**执行不同的操作序列**

举个真实例子，`真理之律者` 的脚本是这样做的：

```python
# 简化示意，完整代码见 agent/custom/action/Role/HerrscherOfTruth.py

工具箱 = CombatActions(context=context, role_name="真理之律者")

# 检查是否处于"常规状态"（通过截图比对攻击键图标来判断）
if 工具箱.check_status("检查常规状态_真理之律者"):
    # 常规状态的打法：放技能 → 普攻几下 → 长按攻击 → 攒大招
    工具箱.use_skill()
    for _ in range(3):
        工具箱.attack()
        time.sleep(0.1)
    工具箱.long_press_attack(700)  # 长按攻击 700 毫秒
    # 攒够能量就放大招
    if 工具箱.check_ultimate_energy_bar():
        工具箱.use_ultimate_skill()
else:
    # 非常规状态（大招阶段）的打法：闪避 → 普攻循环
    工具箱.dodge()
    for _ in range(20):
        # 检查特殊能量条是否满了（通过颜色识别）
        if 工具箱.check_status("检查必杀阶段动能条满_真理之律者"):
            工具箱.long_press_attack(700)
        工具箱.attack()
        time.sleep(0.05)
```

这里用到的 `check_status("节点名")` 就是拿截图去匹配资源文件里定义好的识别节点，匹配上了返回结果，没匹配上返回 `False`。

### 3) 写循环时必须注意的 3 件事（新手容易踩坑）

**第一：一定要加"停止检查"**

任何循环里都要加 `if context.tasker.stopping`，否则用户在界面上点"停止"时，脚本还会继续按键，停不下来。

```python
for _ in range(10):
    if context.tasker.stopping:  # ← 必须加这行
        return CustomAction.RunResult(success=True)
    工具箱.attack()
```

**第二：操作之间要加等待**

`time.sleep(0.05)` 就是等待 0.05 秒。不加等待的话，操作发送太快，游戏可能来不及响应，导致按键"吞掉"或者识别出错。

**第三：不用担心"不在战斗中"的情况**

`attack()`、`dodge()`、`use_skill()` 等方法内部会自动先判断"是否在战斗中"。如果当前不在战斗画面（比如过场动画），这些方法会直接跳过，不会误操作。

---

## 第 2 步：了解战斗工具箱里有什么方法

### 常用战斗动作

下面是 `CombatActions`（也就是"战斗工具箱"）提供的所有常用方法：

| 方法 | 作用 | 说明 |
| --- | --- | --- |
| `attack()` | 普通攻击 | 点一次攻击键 |
| `long_press_attack(毫秒数)` | 长按攻击 | 默认长按 1000 毫秒，可自己指定时长 |
| `dodge()` | 闪避 | 点一次闪避键 |
| `long_press_dodge(毫秒数)` | 长按闪避 | 默认长按 1000 毫秒 |
| `use_skill(等待毫秒数)` | 放技能 | 可选：释放后额外等待指定时间 |
| `use_ultimate_skill(等待毫秒数)` | 放必杀技/大招 | 同上 |
| `trigger_qte(位置)` | 点击换人键 | 位置填 `1` 或 `2`，对应两个队友位 |
| `lens_lock()` | 锁定视角 | 锁定镜头朝向敌人 |
| `co_operation()` | 召唤协同者 | 点击协同者按钮 |

### 常用识别/读取方法

| 方法 | 作用 | 返回值 |
| --- | --- | --- |
| `check_status("节点名")` | 截图并检查某个识别节点是否命中 | 命中返回识别结果，未命中返回 `False` |
| `check_ultimate_energy_bar()` | 检查大招能量是否够了 | 够了返回 `True`，不够返回 `False` |
| `get_hp_percent()` | 获取当前角色血量百分比 | 返回 0～100 的整数 |

**关于 `check_status` 的补充说明**：

这个方法的作用是"拿当前画面去匹配一个你事先定义好的识别规则"。识别规则写在资源文件（`.jsonc`）里，可以是图片比对、颜色检测等方式。

你也可以在调用时临时修改识别参数，不用改资源文件：

```python
# 临时指定要比对的模板图片和匹配精度
结果 = 工具箱.check_status(
    "在战斗中检查角色",
    pipeline_override={
        "在战斗中检查角色": {
            "recognition": {
                "param": {
                    "template": "自动战斗索引/我的角色.png",
                    "threshold": 0.85  # 匹配精度，0～1，越高越严格
                }
            }
        }
    },
)
```

### 切人方法（非常重要）

`switch()` 是切换角色的方法，它会自动完成以下事情：

1. 读取配置，确定要切到哪个队友位（1号位还是 2号位）
2. 点击对应的换人键
3. 通过检测"最大血量是否变化"来判断切人是否成功
4. 如果弹出"本关卡无法复活"的提示，会自动点确认并尝试切到另一个人
5. 切人完成后，自动重新启用角色识别，让程序识别新上场的角色

> **切记**：每个角色脚本结束时，通常都要调用 `工具箱.switch()` 来切人。如果不调用，程序不会自动换人，也不会重新识别角色。

---

## 第 3 步：把你的角色脚本接入系统

写完脚本代码后，还需要做两件配置工作，程序才能"认识"你的角色。

### 3.1) 在角色配置表中添加你的角色

编辑 `agent/custom/utils/RoleConfiguration.py`，在 `ROLE_CONFIG` 字典中增加一条：

```python
ROLE_CONFIG["我的角色名"] = {
    # 注册名，必须和后面在 CustomFile.py 中登记的名字完全一样
    "cls_name": "MyRole",

    "metadata": {
        "DMG": "fire",      # 伤害类型：fire=火 / ice=冰 / lightning=雷 / physical=物理
        "type": "mecha",    # 角色属性：mecha=机械 / psy=异能 / bio=生物 / qua=量子 / img=虚数 / sd=星刃
        "weight": 2,        # 选人权重，数字越大越容易被自动选中
    },

    # 角色头像图片（用于选人界面识别，可暂时不管）
    "template": [
        "自动战斗识别/我的角色头像.png",
    ],

    # 战斗中识别用的攻击键图片（很重要！程序靠这张图判断当前是哪个角色）
    "attack_template": "自动战斗索引/我的角色攻击键.png",
}
```

**各字段解释**：

- `cls_name`：**注册名**。识别到角色后，程序会根据这个名字找到对应的脚本去执行。必须和下一步在 `CustomFile.py` 里登记的名字**完全一致**（区分大小写）。
- `template`：角色头像图片路径（相对于 `assets/resource/image/`），目前主要留作扩展用。
- `attack_template`：**战斗中识别角色的关键图片**。程序会拿这张图和游戏画面右下角的攻击键区域做比对，来判断"当前谁在场上"。

### 3.2) 在注册表中登记你的脚本

编辑 `agent/CustomFile.py`，在文件开头导入你的类，然后注册：

```python
# 在文件开头的导入区域，加上这一行
from agent.custom.action.Role.MyRole import MyRole

# 在文件下方，仿照其他角色的格式，加上注册代码
@AgentServer.custom_action("MyRole")  # ← 这里的名字必须和配置表里的 cls_name 一样
class MyRole_Cls(MyRole):
    def __init__(self):
        super().__init__()
        print(f"{self.__class__.__name__} 初始化")
```

**关键点**：`@AgentServer.custom_action("MyRole")` 括号里的字符串，就是"注册名"。它必须和 `RoleConfiguration.py` 里填的 `cls_name` **完全一样**。

### 3.3) 准备识别用的模板图片

你至少需要提供一张图片：

- 放在 `assets/resource/image/自动战斗索引/` 文件夹下
- 这张图是游戏中该角色**攻击键的截图**（右下角的攻击按钮区域）
- 确保 `RoleConfiguration.py` 里的 `attack_template` 路径指向这张图

> **如果识别不准怎么办？** 通常是以下原因：
>
> - 识别区域没有覆盖到你的模板图片位置
> - 匹配精度设置过高（当前默认是 0.8，即 80% 相似度）
> - 截图不够清晰或包含了多余内容
>
> 可以用 `MaaDebugger` 调试工具来重新截图、调整识别区域。

---

## 第 4 步（可选）：给角色添加专属状态识别

如果你的角色需要判断一些特殊状态（比如"能量条是否满了"、"是否处于大招阶段"、"某个按钮是否亮起"），可以新增专属的识别节点。

### 文件放在哪里

推荐在 `assets/resource/pipeline/战斗逻辑/战斗逻辑/` 下新建一个 `<角色名>.jsonc` 文件。

### 方式一：图片比对（判断某个图标/界面是否出现）

```jsonc
{
    "检查常规状态_我的角色": {
        "recognition": {
            "type": "TemplateMatch",   // 图片比对方式
            "param": {
                "roi": [1061, 494, 219, 226],   // 识别区域：[左上角x, 左上角y, 宽度, 高度]
                "template": ["自动战斗索引/我的角色.png"]   // 要比对的图片
            }
        }
    }
}
```

**`roi` 是什么？** 就是"在屏幕上的哪个区域去找"。格式是 `[x坐标, y坐标, 宽度, 高度]`，从屏幕左上角开始算。设置合适的识别区域可以提升识别速度和准确度。

### 方式二：颜色检测（判断能量条、按钮高亮等）

```jsonc
{
    "检查某条是否满_我的角色": {
        "recognition": {
            "type": "ColorMatch",   // 颜色检测方式
            "param": {
                "roi": [650, 620, 20, 20],      // 识别区域
                "lower": [200, 120, 40],         // 颜色下限 [红, 绿, 蓝]
                "upper": [255, 160, 90],         // 颜色上限 [红, 绿, 蓝]
                "count": 20,                     // 至少有多少个像素点在颜色范围内才算命中
                "connected": true                // 是否要求这些像素点连在一起
            }
        }
    }
}
```

### 在脚本中调用

写好识别节点后，在你的角色脚本里这样用：

```python
if 工具箱.check_status("检查某条是否满_我的角色"):
    工具箱.long_press_attack(700)  # 满了就长按攻击
```

---

## 两种常见的编写思路

### 思路一：全部用代码编排（推荐新手使用）

像 `HerrscherOfTruth.py`（真理之律者）、`GeneralFight.py`（通用战斗）一样：

- 所有战斗动作都在代码里用 `attack()`、`use_skill()` 等方法一步步写
- **优点**：逻辑集中在一个文件里，好理解、好调试
- **缺点**：如果动作特别多，代码会比较长

### 思路二：资源文件里写流程，代码只负责触发

像 `LoveElf.py`（爱愿妖精）、`SpinaAstera.py`（孑遗千星）一样：

- 把大量的按键序列、坐标滑动等写在资源文件的节点里（`.json`）
- 代码里简单一行就触发整个流程
- **优点**：大量坐标和滑动操作放在资源文件里更方便调整
- **缺点**：需要熟悉资源文件的节点组织方式，上手门槛更高

**建议**：新手先用思路一，等熟悉框架后再尝试思路二。

---

## 调试建议

### 看日志

- 战斗工具箱会自动写入日志到 `debug/custom_日期.log`，里面会标注角色名，方便定位问题
- 通用日志在 `debug/agent.log`

### 用调试工具

- 推荐安装 `MaaDebugger` 或 `Maa Pipeline Support` 插件
- 可以快速截图、圈选识别区域、测试颜色范围、验证图片识别效果

---

## 常见问题

### 问题 1：写了角色脚本，但战斗中从来不执行

按以下顺序排查：

1. **注册名是否一致**：`RoleConfiguration.py` 里的 `cls_name` 和 `CustomFile.py` 里 `@AgentServer.custom_action("...")` 括号中的字符串必须**完全一样**（注意大小写）
2. **识别图片是否存在**：检查 `attack_template` 指向的图片文件是否在 `assets/resource/image/` 目录下
3. **识别区域是否正确**：`自动战斗工具方法.jsonc` 里 `在战斗中检查角色` 的识别区域是否覆盖到了攻击键位置
4. **匹配精度**：当前默认要求 80% 相似度，如果截图质量不高可以适当降低

### 问题 2：切人后脚本没有跟着换

确保你的角色脚本最后调用了 `工具箱.switch()`。这个方法会在切人完成后重新启用角色识别，程序才会识别新角色并执行对应脚本。

### 问题 3：按键错位 / 识别一直不准

通常是分辨率或资源包的问题：

- 确认游戏分辨率是 **16:9** 比例
- 电脑端和模拟器使用了正确的资源包（电脑端用 `resource_win32`，模拟器用 `resource`）
- 用调试工具重新截图、重新框选识别区域
